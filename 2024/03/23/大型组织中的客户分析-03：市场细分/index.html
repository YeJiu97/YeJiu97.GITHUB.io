<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="大型组织中的客户分析 笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="大型组织中的客户分析-03：市场细分">
<meta property="og:url" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/index.html">
<meta property="og:site_name" content="夜久">
<meta property="og:description" content="大型组织中的客户分析 笔记">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323150930058.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323154931064.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323160755388.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323161022398.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323161400871.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323221737288.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323161710130.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323221839425.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323164359155.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323165341659.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323165524283.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323165557120.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323170014385.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323170137424.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323170259910.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323170443695.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323170556064.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323170627297.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323184837154.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323190803521.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323190919377.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323191243906.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323194633721.png">
<meta property="og:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323195343526.png">
<meta property="article:published_time" content="2024-03-22T20:56:33.000Z">
<meta property="article:modified_time" content="2024-03-23T11:50:30.069Z">
<meta property="article:author" content="Ye Jiu">
<meta property="article:tag" content="数据分析">
<meta property="article:tag" content="客户分析">
<meta property="article:tag" content="统计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323150930058.png">


<link rel="canonical" href="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/","path":"2024/03/23/大型组织中的客户分析-03：市场细分/","title":"大型组织中的客户分析-03：市场细分"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>大型组织中的客户分析-03：市场细分 | 夜久</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">夜久</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-about"><a href="/about" rel="section">About</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section">Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section">Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

<iframe width="100%" height="166" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/848368468&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true"></iframe><div style="font-size: 10px; color: #cccccc;line-break: anywhere;word-break: normal;overflow: hidden;white-space: nowrap;text-overflow: ellipsis; font-family: Interstate,Lucida Grande,Lucida Sans Unicode,Lucida Sans,Garuda,Verdana,Tahoma,sans-serif;font-weight: 100;"><a href="https://soundcloud.com/terence-vassallo-415912750" title="Ocelotter" target="_blank" style="color: #cccccc; text-decoration: none;">Ocelotter</a> · <a href="https://soundcloud.com/terence-vassallo-415912750/euphoria" title="Euphoria - 楽園の扉 中日字幕" target="_blank" style="color: #cccccc; text-decoration: none;">Euphoria - 楽園の扉 中日字幕</a></div>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=535990&auto=1&height=66"></iframe>

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86"><span class="nav-number">1.</span> <span class="nav-text">市场细分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86"><span class="nav-number">1.1.</span> <span class="nav-text">什么是市场细分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86"><span class="nav-number">1.2.</span> <span class="nav-text">如何选择市场细分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BE%E5%AE%A2%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">1.3.</span> <span class="nav-text">顾客与消费者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8"><span class="nav-number">1.4.</span> <span class="nav-text">数据驱动</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86"><span class="nav-number">2.</span> <span class="nav-text">如何进行市场细分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%86%E5%88%86%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">细分方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E7%B1%BB-Clustering"><span class="nav-number">2.2.</span> <span class="nav-text">聚类 Clustering</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E7%B1%BB"><span class="nav-number">2.3.</span> <span class="nav-text">什么是聚类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#one-hot-encoding"><span class="nav-number">2.4.</span> <span class="nav-text">one-hot encoding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Distance"><span class="nav-number">2.5.</span> <span class="nav-text">Distance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E7%B1%BB%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="nav-number">2.6.</span> <span class="nav-text">聚类类型与聚类算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E5%92%8CR%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81"><span class="nav-number">3.</span> <span class="nav-text">数据集和R语言代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ye Jiu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ye Jiu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夜久">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="大型组织中的客户分析-03：市场细分 | 夜久">
      <meta itemprop="description" content="大型组织中的客户分析 笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          大型组织中的客户分析-03：市场细分
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-03-23 07:26:33 / Modified: 22:20:30" itemprop="dateCreated datePublished" datetime="2024-03-23T07:26:33+10:30">2024-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">大型组织中的客户分析</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">大型组织中的客户分析 笔记</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="市场细分"><a href="#市场细分" class="headerlink" title="市场细分"></a>市场细分</h1><h2 id="什么是市场细分"><a href="#什么是市场细分" class="headerlink" title="什么是市场细分"></a><strong>什么是市场细分</strong></h2><p>在市场细分中，我们首先将受众根据特定特征或需求进行分类，这些特征可以是性别、年龄、文化背景、地理位置等。比如，男性和女性可能在购买服装和鞋类时有不同的偏好和需求，儿童市场也是一个独立的细分市场。</p>
<p>气候或文化差异也是市场细分的重要考虑因素。例如，在不同气候条件下，消费者对服装、食品和饮料的需求可能有所不同。同样，不同文化背景的消费者可能对产品的偏好和需求也有所不同。</p>
<p>目标或定位则是针对特定的细分市场制定营销策略的过程。这包括确定目标市场，并通过定位策略将公司的产品或服务定位为满足该市场需求的最佳选择。例如，Peroni啤酒将其定位为一种地道的意大利啤酒，从而吸引那些对意大利文化或啤酒品质有特殊偏好的消费者。</p>
<p>意大利披萨是另一个例子，它通过将自己定位为正宗的意大利披萨，吸引了那些寻找真正意大利风味的消费者。通过这种目标和定位策略，公司可以更有效地吸引并满足特定细分市场的需求，提高市场占有率和品牌认知度。</p>
<h2 id="如何选择市场细分"><a href="#如何选择市场细分" class="headerlink" title="如何选择市场细分"></a><strong>如何选择市场细分</strong></h2><p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323150930058.png" alt="image-20240323150930058"></p>
<p>根据图片所示,研究人员可以基于不同的基础或变量来对目标市场或受众进行细分。图中列出的分段基础包括:</p>
<ol>
<li><p>人口统计学:包括年龄、性别、收入、职业、教育程度、家庭规模和地理位置等因素。基于这些人口统计特征进行细分有助于了解和针对特定的人群。</p>
</li>
<li><p>心理特征:涉及根据态度、观点、活动、个性、生活方式、兴趣和价值观等心理和行为特征进行细分。</p>
</li>
<li><p>行为:基于使用率、主要品牌和使用的媒体等实际行为和消费模式进行细分。</p>
</li>
<li><p>其他:包括基于场合&#x2F;情境、寻求的利益和媒体习惯等其他可能影响消费者行为或偏好的因素进行细分。</p>
</li>
</ol>
<p>通过考虑这些不同的细分基础,研究人员可以选择最相关的单一变量或多个变量的组合,将目标市场或受众划分为不同的细分群体。这有助于实施更有针对性和有效的营销策略、产品开发或对特定受众群体的理解。</p>
<h2 id="顾客与消费者"><a href="#顾客与消费者" class="headerlink" title="顾客与消费者"></a><strong>顾客与消费者</strong></h2><p>顾客与消费者是在市场营销和商业领域经常使用的两个术语，它们虽然有关联，但指代的对象略有不同。</p>
<ol>
<li><p><strong>顾客（Customers）</strong>：</p>
<ul>
<li><p><strong>定义</strong>：顾客通常指购买产品或服务的个人或实体，他们直接从公司购买产品或服务，或者通过其他渠道（例如零售商）购买。顾客是公司业务活动的直接参与者。</p>
</li>
<li><p><strong>角色</strong>：顾客在交易中通常是支付货款的一方，他们可能通过购买产品或服务来满足自己的需求或愿望。顾客与公司有直接的买卖关系，因此公司会对他们进行市场定位和营销活动，以吸引他们购买产品或服务。</p>
</li>
</ul>
</li>
<li><p><strong>消费者（Consumers）</strong>：</p>
<ul>
<li><p><strong>定义</strong>：消费者是最终使用产品或服务的个人或实体。他们可能是顾客，也可能不是。消费者使用产品或服务来满足自己的需求或愿望，但他们不一定是直接购买这些产品或服务的人。</p>
</li>
<li><p><strong>角色</strong>：消费者是产品或服务的最终目标，他们是产品或服务的最终用户。即使消费者不直接购买产品，但他们使用产品或服务后对品牌形象和市场口碑也会产生影响。因此，公司也会针对消费者的需求进行产品设计、品牌定位和营销活动。</p>
</li>
</ul>
</li>
</ol>
<p><strong>比较</strong>：</p>
<ul>
<li><p><strong>关系</strong>：顾客可以是消费者，但不一定如此。消费者是最终使用产品或服务的个体，而顾客是直接购买产品或服务的个体。</p>
</li>
<li><p><strong>行为</strong>：顾客直接参与购买行为，而消费者则是最终使用产品或服务的个体，他们可能与购买者不同。</p>
</li>
<li><p><strong>影响</strong>：顾客通过购买行为直接支持公司的业务，而消费者的使用行为可能会影响产品或服务的市场表现和品牌形象。</p>
</li>
</ul>
<p>总的来说，顾客和消费者是市场营销中两个重要但略有不同的概念，理解它们的差异有助于企业更好地理解和满足市场需求。</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>顾客（Customers）</th>
<th>消费者（Consumers）</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>直接购买产品或服务的个人或实体</td>
<td>最终使用产品或服务的个人或实体</td>
</tr>
<tr>
<td>角色</td>
<td>购买产品或服务，参与交易</td>
<td>使用产品或服务，可能不参与交易</td>
</tr>
<tr>
<td>关系</td>
<td>可能是消费者，但不一定如此</td>
<td>最终产品或服务的目标用户</td>
</tr>
<tr>
<td>行为</td>
<td>直接参与购买行为，支付货款</td>
<td>使用产品或服务，不一定购买</td>
</tr>
<tr>
<td>影响</td>
<td>支持公司业务，影响销售和营收</td>
<td>影响产品或服务的市场表现和品牌形象</td>
</tr>
</tbody></table>
<p>这个表格清晰地对比了顾客和消费者在定义、角色、关系、行为和影响等方面的差异。</p>
<h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a><strong>数据驱动</strong></h2><p>数据库驱动的定位（Database-driven targeting）是一种营销策略，它利用数据库中存储的客户信息和行为数据来精确地定位和针对特定的目标受众进行营销活动。这种策略依赖于数据库技术和数据分析，以更好地理解客户群体，提供个性化的营销内容和服务。</p>
<p>这个过程通常包括以下步骤：</p>
<ol>
<li><p><strong>数据收集</strong>：收集和整理来自各种渠道（如网站、社交媒体、购买历史等）的客户数据，包括个人信息、行为偏好、购买历史、交互记录等。</p>
</li>
<li><p><strong>数据分析</strong>：利用数据分析工具和技术对收集到的数据进行分析和挖掘，以识别客户群体的特征、偏好和行为模式。这包括利用数据挖掘算法来发现隐藏在数据中的模式和趋势。</p>
</li>
<li><p><strong>目标设定</strong>：根据数据分析的结果，确定目标受众的特征和需求。这可能包括确定特定人群的地理位置、年龄、性别、兴趣爱好、购买行为等。</p>
</li>
<li><p><strong>个性化营销</strong>：根据目标受众的特征和需求，制定个性化的营销策略和内容。这可能包括定制的广告、优惠券、促销活动、电子邮件营销等，以满足目标受众的需求，并提高营销效果和客户参与度。</p>
</li>
<li><p><strong>实时优化</strong>：不断监测和分析营销活动的效果，并根据实时数据对营销策略进行调整和优化，以提高营销效果和ROI（投资回报率）。</p>
</li>
</ol>
<p>数据库驱动的定位能够帮助企业更好地理解和满足客户需求，提高营销效率和客户满意度，从而实现更好的业务结果。</p>
<p>Recency, Frequency, and Monetary Value (RFM) 是一种用于客户分析和客户管理的常用方法。它基于以下三个方面对客户进行评估：</p>
<ol>
<li><p><strong>Recency（最近购买）</strong>：衡量客户最近一次购买产品或服务的时间。通常，最近购买的客户被认为更有可能对新的促销或产品感兴趣，因此是具有潜在价值的客户。</p>
</li>
<li><p><strong>Frequency（购买频率）</strong>：衡量客户在一定时间内购买产品或服务的频率。频繁购买的客户往往对公司的产品或服务有较高的忠诚度，并且更有可能成为重要的长期客户。</p>
</li>
<li><p><strong>Monetary Value（购买金额）</strong>：衡量客户在一定时间内购买产品或服务的总金额。购买金额较高的客户可能对公司的利润贡献更大，因此值得特别关注和奖励。</p>
</li>
</ol>
<p>RFM分析通过将客户根据这三个方面的表现分成不同的类别，从而帮助企业更好地理解客户群体并制定相应的营销策略。比如，公司可以将客户分为高价值、中等价值和低价值客户，然后针对不同类别的客户制定不同的促销活动和客户关怀计划，以最大程度地提高客户忠诚度和公司利润。</p>
<p>在客户分析中，通常也会将现有客户与新客户进行对比。现有客户是已经购买过产品或服务的客户，对于他们，公司可以通过RFM分析来识别并奖励最具价值的客户，以保持其忠诚度并鼓励他们继续购买。而新客户则是公司的潜在增长来源，公司可以利用RFM分析来了解他们的行为和偏好，从而制定针对性的营销策略以吸引他们成为忠诚客户。</p>
<p>另外，RFM分析也可以帮助区分重度客户和轻度客户。重度客户通常具有高频率、高金额和较近的购买历史，他们对公司的利润贡献较大；而轻度客户则相反，他们的购买行为可能不够频繁或者购买金额较低，因此可能需要特别关注以提高其购买频率和购买金额。</p>
<p>假设有一家在线零售商，他们销售各种家居用品。他们想要利用RFM分析来更好地了解他们的客户群体，并制定相应的营销策略。</p>
<ol>
<li><p><strong>RFM分析</strong>：</p>
<ul>
<li><p><strong>Recency（最近购买）</strong>：他们分析了过去12个月内客户最近一次购买产品的时间。他们将客户分成了三个组别：最近购买时间在0-30天内的客户为高Recency客户，31-90天内的为中Recency客户，超过90天为低Recency客户。</p>
</li>
<li><p><strong>Frequency（购买频率）</strong>：他们查看了客户过去12个月内的购买频率。他们将客户分成了三个组别：购买频率高于平均值的为高Frequency客户，等于平均值的为中Frequency客户，低于平均值的为低Frequency客户。</p>
</li>
<li><p><strong>Monetary Value（购买金额）</strong>：他们计算了客户过去12个月内的总购买金额。他们将客户分成了三个组别：购买金额高于平均值的为高Monetary Value客户，等于平均值的为中Monetary Value客户，低于平均值的为低Monetary Value客户。</p>
</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<p>通过RFM分析，他们发现了以下两个具体的客户群体：</p>
<ul>
<li><p><strong>高价值忠诚客户</strong>：这些客户最近购买了产品（高Recency），购买频率高（高Frequency），且总购买金额大（高Monetary Value）。这些客户是该公司的核心客户群体，公司应该重点关注并提供特别的服务和奖励以保持他们的忠诚度和增加他们的购买量。</p>
</li>
<li><p><strong>新客户潜力群体</strong>：这些客户可能最近才购买了产品（低Recency），购买频率可能还不够高（中Frequency），但他们的购买金额较大（高Monetary Value）。这些客户是潜在的增长来源，公司可以通过定向营销活动和个性化服务来吸引他们成为忠诚客户。</p>
</li>
</ul>
</li>
</ol>
<p>基于这些分析结果，公司可以制定针对不同客户群体的营销策略，例如对高价值忠诚客户提供定制化的促销活动和忠诚度奖励，对新客户潜力群体则提供特别的欢迎优惠和个性化的购物建议，以提高他们的购买频率和忠诚度。</p>
<p>以下是一个完整的表格，根据RFM分析整理的不同客户群体的特征和分类：</p>
<table>
<thead>
<tr>
<th>客户群体</th>
<th>最近购买（Recency）</th>
<th>购买频率（Frequency）</th>
<th>总购买金额（Monetary Value）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>高价值忠诚客户</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>最近购买，频率高，总购买金额大。是核心客户，需重点关注。</td>
</tr>
<tr>
<td>一般忠诚客户</td>
<td>中</td>
<td>中</td>
<td>中</td>
<td>购买行为一般，需保持忠诚度，可能需要激励措施。</td>
</tr>
<tr>
<td>潜在增长客户</td>
<td>低</td>
<td>高</td>
<td>中</td>
<td>最近购买较少，但购买频率高，有潜力成为忠诚客户。</td>
</tr>
<tr>
<td>一般客户</td>
<td>中</td>
<td>中</td>
<td>中</td>
<td>购买行为一般，对公司贡献一般，需加强营销与关怀。</td>
</tr>
<tr>
<td>低价值客户</td>
<td>低</td>
<td>低</td>
<td>低</td>
<td>最近购买较少，频率低，购买金额小。可能是流失客户，需要重新吸引。</td>
</tr>
</tbody></table>
<p>通过这个完整的表格，公司可以清晰地了解不同客户群体的特征，并据此制定相应的营销策略，以提高客户忠诚度、增加销售额并改善客户满意度。</p>
<h1 id="如何进行市场细分"><a href="#如何进行市场细分" class="headerlink" title="如何进行市场细分"></a>如何进行市场细分</h1><h2 id="细分方法"><a href="#细分方法" class="headerlink" title="细分方法"></a>细分方法</h2><p>市场细分的方法可以通过以下几种方式进行：</p>
<ol>
<li><p><strong>业务规则</strong>：基于公司内部的业务规则和逻辑来划分市场。这可能涉及到根据产品特性、客户需求、地理位置等因素来确定不同市场细分的标准。</p>
</li>
<li><p><strong>人为标准</strong>：利用人为选择的标准，如人口统计学、心理学或行为学等方面的因素来进行市场细分。比如，根据年龄、性别、收入、兴趣爱好、购买行为等因素来将市场细分为不同的目标群体。</p>
</li>
<li><p><strong>分位数&#x2F;阈值法</strong>：根据人为设置的分位数或阈值来对客户进行分类。例如，将客户根据购买频率、消费金额等指标的分位数来划分为高、中、低等级别，或者根据特定指标的阈值来确定客户是否属于某个细分市场。</p>
</li>
<li><p><strong>聚类</strong>：利用聚类分析等无监督学习方法，通过对客户数据进行统计分析和模式识别来发现隐藏在数据中的客户群体。这些方法能够自动识别具有相似特征和行为模式的客户，并将其归类为同一市场细分。</p>
</li>
</ol>
<p>这些方法可以单独使用，也可以结合使用，根据具体情况选择最合适的方法来进行市场细分。无论使用哪种方法，市场细分的目的都是为了更好地理解和满足不同客户群体的需求，从而实现更有效的营销和客户管理策略。</p>
<h2 id="聚类-Clustering"><a href="#聚类-Clustering" class="headerlink" title="聚类 Clustering"></a>聚类 Clustering</h2><h2 id="什么是聚类"><a href="#什么是聚类" class="headerlink" title="什么是聚类"></a>什么是聚类</h2><p>聚类是一种无监督学习方法，用于将数据集中的对象分成相似的组别，使得同一组内的对象彼此相似度高，而不同组之间的对象相似度较低。聚类分析旨在发现数据中的固有结构，以便更好地理解数据并提取有用的信息。</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323154931064.png" alt="image-20240323154931064"></p>
<p>聚类的目标是将数据点划分为多个不同的群组，使得同一组内的数据点之间的相似度较高，而不同组之间的相似度较低。在聚类分析中，通常不需要预先确定群组的数量，而是通过算法自动确定最佳的群组数量。</p>
<p>可以使用以下步骤来进行聚类分析：</p>
<ol>
<li><strong>选择有意义的变量</strong>： 首先，我们需要选择适当的变量来进行聚类分析。这些变量应该是能够反映数据样本特征的重要属性。例如，如果我们正在分析顾客群体，可能会选择年龄、性别、购买频率、购买金额等作为变量。<ul>
<li><p>对分析目标有意义：所选变量与分析的目标密切相关，能够有效地反映所研究的问题或现象。</p>
</li>
<li><p>相对独立：所选变量之间相互独立或具有较低的相关性，以确保分析结果的准确性和可靠性。</p>
</li>
<li><p>数量有限：所选变量的数量是有限的，不过多，以避免过度复杂的模型和分析过程。</p>
</li>
<li><p>数值型（对分类变量进行独热编码）：所选变量是数值型的，或者可以通过独热编码转换为数值型，以便于数学计算和分析处理。</p>
</li>
<li><p>峰度和偏度统计量较低（至少在训练集中）：所选变量的峰度和偏度统计量较低，表明数据分布相对对称且没有明显的长尾，以确保模型的稳健性和可靠性。</p>
</li>
</ul>
</li>
<li><strong>选择距离或相似度的度量</strong>： 在进行聚类分析之前，我们需要选择适当的距离或相似度度量来衡量数据样本之间的相似程度或差异。常用的度量方法包括欧氏距离、曼哈顿距离、余弦相似度等。</li>
<li><strong>最大化组间距离，最小化组内距离</strong>： 在执行聚类算法时，我们的目标是通过调整聚类的方式，使得组间的距离最大化，而组内的距离最小化。这意味着我们希望同一组内的样本尽可能相似，而不同组之间的样本尽可能不相似。</li>
<li><strong>解释聚类结果</strong>： 最后，我们需要解释聚类结果，以理解每个聚类所代表的含义和特征。这可能涉及到对每个聚类的中心或代表性样本进行分析，以确定它们之间的共同特征和差异。通过这样的解释，我们可以更好地理解数据并提取有用的信息。</li>
</ol>
<h2 id="one-hot-encoding"><a href="#one-hot-encoding" class="headerlink" title="one-hot encoding"></a>one-hot encoding</h2><p>一热编码（One-hot encoding）是一种常用的数据预处理技术，用于将分类变量转换为数值型变量，以便于机器学习算法的处理。</p>
<p>在一热编码中，对于每个分类变量的每个可能取值，都会创建一个新的二进制特征（或称为虚拟变量）。如果某个样本属于该取值，则对应的二进制特征为1，否则为0。这样，原始的分类变量就被转换成了一个由0和1组成的向量，其中每个取值都对应一个二进制位。</p>
<p>例如，假设有一个分类变量“颜色”，可能的取值包括“红色”、“绿色”和“蓝色”。使用一热编码，可以将“颜色”变量转换为三个新的二进制特征：“颜色_红色”、“颜色_绿色”和“颜色_蓝色”。如果一个样本的颜色是“绿色”，则对应的向量为[0, 1, 0]。</p>
<p>一热编码的优点包括：</p>
<ul>
<li>避免了将分类变量视为连续变量的误解。</li>
<li>不会引入不必要的大小关系，使得模型更准确地捕捉到分类变量之间的差异。</li>
<li>适用于大多数机器学习算法，包括线性模型和树形模型等。</li>
</ul>
<p>需要注意的是，一热编码会增加特征的维度，特别是对于具有大量可能取值的分类变量，可能会导致维度爆炸的问题。因此，在使用一热编码时，需要根据实际情况考虑是否适合。</p>
<p>代码例子。</p>
<p>首先，我们创建了一个名为<code>customers</code>的数据框（data frame），其中包含了顾客的ID、性别和心情三个变量：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">customers <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>id<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                        gender<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;M&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;M&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;M&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;F&#x27;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                        mood<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;happy&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;sad&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;happy&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;sad&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们查看了<code>customers</code>数据框的内容：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> customers</span><br><span class="line">  id gender  mood</span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>      M happy</span><br><span class="line"><span class="number">2</span>  <span class="number">2</span>      M   sad</span><br><span class="line"><span class="number">3</span>  <span class="number">3</span>      M happy</span><br><span class="line"><span class="number">4</span>  <span class="number">4</span>      <span class="built_in">F</span>   sad</span><br></pre></td></tr></table></figure>

<p>然后，我们加载了<code>data.table</code>和<code>mltools</code>库，并使用<code>one_hot</code>函数对<code>customers</code>数据框进行一热编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(data.table)</span><br><span class="line">library(mltools)</span><br><span class="line">customers &lt;- one_hot(as.data.table(customers))</span><br></pre></td></tr></table></figure>

<p>最后，我们查看了经过一热编码后的<code>customers</code>数据框的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; customers</span><br><span class="line">   id gender_F gender_M mood_happy mood_sad</span><br><span class="line">1:  1        0        1          1        0</span><br><span class="line">2:  2        0        1          0        1</span><br><span class="line">3:  3        0        1          1        0</span><br><span class="line">4:  4        1        0          0        1</span><br></pre></td></tr></table></figure>

<p>在经过一热编码后，原始的<code>gender</code>和<code>mood</code>变量被转换成了四个新的二进制特征：<code>gender_F</code>（女性）、<code>gender_M</code>（男性）、<code>mood_happy</code>（心情愉快）、<code>mood_sad</code>（心情悲伤）。这样，每个变量的每个可能取值都被转换成了一个新的二进制特征，方便后续的数据分析和建模。</p>
<p>上述代码可能因为版本问题无法很好的one_hot，可以采用以下代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 加载必要的库</span></span><br><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span>data.table<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span>mltools<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> </span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建数据框</span></span><br><span class="line"><span class="operator">&gt;</span> customers <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>id<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line"><span class="operator">+</span>                         gender<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;M&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;M&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;M&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;F&#x27;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line"><span class="operator">+</span>                         mood<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;happy&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;sad&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;happy&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;sad&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> </span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 将分类变量转换为因子变量</span></span><br><span class="line"><span class="operator">&gt;</span> customers<span class="operator">$</span>gender <span class="operator">&lt;-</span> as.factor<span class="punctuation">(</span>customers<span class="operator">$</span>gender<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> customers<span class="operator">$</span>mood <span class="operator">&lt;-</span> as.factor<span class="punctuation">(</span>customers<span class="operator">$</span>mood<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> </span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 将数据框转换为 data.table</span></span><br><span class="line"><span class="operator">&gt;</span> customers_dt <span class="operator">&lt;-</span> as.data.table<span class="punctuation">(</span>customers<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> </span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 对分类变量进行 one-hot 编码</span></span><br><span class="line"><span class="operator">&gt;</span> customers_encoded <span class="operator">&lt;-</span> one_hot<span class="punctuation">(</span>customers_dt<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> </span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 打印编码后的结果</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>customers_encoded<span class="punctuation">)</span></span><br><span class="line">      id gender_F gender_M mood_happy mood_sad</span><br><span class="line">   <span class="operator">&lt;</span>num<span class="operator">&gt;</span>    <span class="operator">&lt;</span>int<span class="operator">&gt;</span>    <span class="operator">&lt;</span>int<span class="operator">&gt;</span>      <span class="operator">&lt;</span>int<span class="operator">&gt;</span>    <span class="operator">&lt;</span>int<span class="operator">&gt;</span></span><br><span class="line"><span class="number">1</span><span class="operator">:</span>     <span class="number">1</span>        <span class="number">0</span>        <span class="number">1</span>          <span class="number">1</span>        <span class="number">0</span></span><br><span class="line"><span class="number">2</span><span class="operator">:</span>     <span class="number">2</span>        <span class="number">0</span>        <span class="number">1</span>          <span class="number">0</span>        <span class="number">1</span></span><br><span class="line"><span class="number">3</span><span class="operator">:</span>     <span class="number">3</span>        <span class="number">0</span>        <span class="number">1</span>          <span class="number">1</span>        <span class="number">0</span></span><br><span class="line"><span class="number">4</span><span class="operator">:</span>     <span class="number">4</span>        <span class="number">1</span>        <span class="number">0</span>          <span class="number">0</span>        <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Distance"><a href="#Distance" class="headerlink" title="Distance"></a>Distance</h2><p><u><strong>曼哈顿距离</strong></u></p>
<p>曼哈顿距离（Manhattan distance），也称为城市街区距离或L1距离，是欧几里德空间中两点之间的距离的度量方式之一。它表示两点在水平和垂直方向上的距离总和，就像在城市街区中沿着网格道路行走一样。</p>
<p>对于二维空间中的两个点 $P_1(x_1, y_1)$ 和 $P_2(x_2, y_2)$，曼哈顿距离 $d$ 可以由以下公式计算：</p>
<p>$d &#x3D; |x_1 - x_2| + |y_1 - y_2|$</p>
<p>换句话说，曼哈顿距离是从一个点到另一个点沿着水平和垂直方向的路径长度之和，如同在城市中从一个交叉路口到另一个交叉路口，必须沿着网格状的道路行进一样。</p>
<p>曼哈顿距离的特点包括：</p>
<ol>
<li><p><strong>不依赖于坐标系的方向</strong>：无论两点在坐标系中的位置如何，曼哈顿距离总是相同的。这与欧几里德距离不同，欧几里德距离会受到坐标轴旋转的影响。</p>
</li>
<li><p><strong>适用于离散空间和路径规划</strong>：由于曼哈顿距离在离散空间中的计算方式，因此它通常用于路径规划问题，如在城市地图中找到最短路径。</p>
</li>
<li><p><strong>计算简单</strong>：与其他距离度量相比，曼哈顿距离的计算非常简单，只需要计算两点之间水平和垂直方向上的差值的绝对值之和。</p>
</li>
</ol>
<p>曼哈顿距离在各种领域都有广泛的应用，包括机器学习、图像处理、城市规划等。</p>
<p>使用Python语言进行可视化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个点的坐标</span></span><br><span class="line">point1 = np.array([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">point2 = np.array([<span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算曼哈顿距离</span></span><br><span class="line">manhattan_distance = np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(point1 - point2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化两个点和曼哈顿距离</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot([point1[<span class="number">0</span>], point2[<span class="number">0</span>]], [point1[<span class="number">1</span>], point1[<span class="number">1</span>]], <span class="string">&#x27;ro--&#x27;</span>, label=<span class="string">&#x27;Point 1&#x27;</span>)</span><br><span class="line">plt.plot([point2[<span class="number">0</span>], point2[<span class="number">0</span>]], [point1[<span class="number">1</span>], point2[<span class="number">1</span>]], <span class="string">&#x27;ro--&#x27;</span>)</span><br><span class="line">plt.plot([point1[<span class="number">0</span>], point2[<span class="number">0</span>]], [point2[<span class="number">1</span>], point2[<span class="number">1</span>]], <span class="string">&#x27;ro--&#x27;</span>, label=<span class="string">&#x27;Point 2&#x27;</span>)</span><br><span class="line">plt.plot([point1[<span class="number">0</span>], point1[<span class="number">0</span>]], [point1[<span class="number">1</span>], point2[<span class="number">1</span>]], <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line">plt.plot([point2[<span class="number">0</span>], point1[<span class="number">0</span>]], [point2[<span class="number">1</span>], point2[<span class="number">1</span>]], <span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;Manhattan Distance&#x27;</span>)</span><br><span class="line">plt.text(<span class="number">2.5</span>, <span class="number">2.5</span>, <span class="built_in">str</span>(manhattan_distance), fontsize=<span class="number">12</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X-axis&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y-axis&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Manhattan Distance&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>得到的结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323160755388.png" alt="image-20240323160755388"></p>
<p><u><strong>欧氏距离</strong></u></p>
<p>欧氏距离（Euclidean distance），也称为直线距离或L2距离，是欧几里德空间中两点之间的距离的度量方式之一。它表示两点之间的最短直线距离，就像在平面上两点之间画一条直线一样。</p>
<p>对于二维空间中的两个点 $P_1(x_1, y_1)$ 和 $P_2(x_2, y_2)$，欧氏距离 $d$ 可以由以下公式计算：</p>
<p>$d &#x3D; \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$</p>
<p>换句话说，欧氏距离是两点之间的直线距离，就像我们在平面上测量两点之间的距离一样。</p>
<p>欧氏距离的特点包括：</p>
<ol>
<li><p><strong>最短路径</strong>：欧氏距离表示两点之间最短的直线路径，是两点之间最直接的距离。</p>
</li>
<li><p><strong>连续空间的度量</strong>：欧氏距离通常用于连续空间中的点的度量，如二维平面或三维空间中的点。</p>
</li>
<li><p><strong>与坐标轴方向无关</strong>：欧氏距离不受坐标轴方向的影响，即两点之间的距离与坐标轴的方向无关。</p>
</li>
</ol>
<p>欧氏距离在各种领域都有广泛的应用，包括机器学习、数据挖掘、图像处理等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个点的坐标</span></span><br><span class="line">point1 = np.array([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">point2 = np.array([<span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算欧氏距离</span></span><br><span class="line">euclidean_distance = np.linalg.norm(point1 - point2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化两个点和欧氏距离</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot([point1[<span class="number">0</span>], point2[<span class="number">0</span>]], [point1[<span class="number">1</span>], point2[<span class="number">1</span>]], <span class="string">&#x27;ro--&#x27;</span>, label=<span class="string">&#x27;Euclidean Distance&#x27;</span>)</span><br><span class="line">plt.text(<span class="number">2.5</span>, <span class="number">4</span>, <span class="built_in">str</span>(<span class="built_in">round</span>(euclidean_distance, <span class="number">2</span>)), fontsize=<span class="number">12</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X-axis&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y-axis&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Euclidean Distance&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>得到的结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323161022398.png" alt="image-20240323161022398"></p>
<p><u><strong>Minkowski distance</strong></u></p>
<p>明科夫斯基距离（Minkowski distance）是欧氏距离和曼哈顿距离的一般化形式，它表示在 n 维空间中两点之间的距离。明科夫斯基距离的计算方式由以下公式给出：</p>
<p>$ D(x, y) &#x3D; \left( \sum_{i&#x3D;1}^{n} |x_i - y_i|^p \right)^{\frac{1}{p}} $</p>
<p>其中，$ x $ 和 $ y $ 是 n 维空间中的两个点，$ x_i $ 和 $ y_i $ 分别是点 $ x $ 和 $ y $ 在第 $ i $ 个维度上的坐标，$ p $ 是一个大于等于1的常数。</p>
<p>当 $ p &#x3D; 1 $ 时，明科夫斯基距离退化为曼哈顿距离；当 $ p &#x3D; 2 $ 时，明科夫斯基距离退化为欧氏距离。因此，明科夫斯基距离是曼哈顿距离和欧氏距离的一般化形式，可以根据参数 $ p $ 的不同取值，调整距离的计算方式。</p>
<p>明科夫斯基距离的特点包括：</p>
<ul>
<li>可以适用于任意维度的空间；</li>
<li>当 $ p &#x3D; 1 $ 时，考虑了各维度坐标的绝对值之和，适用于离散特征的距离度量；</li>
<li>当 $ p &#x3D; 2 $ 时，考虑了各维度坐标的平方和，适用于连续特征的距离度量；</li>
<li>当 $ p \rightarrow \infty $ 时，即切比雪夫距离（Chebyshev distance），只考虑各维度坐标的最大差值。</li>
</ul>
<p>明科夫斯基距离在机器学习中被广泛应用，特别是在分类、聚类和回归等任务中的距离度量和相似性计算中。</p>
<p>Python语言代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个点的坐标（3 维）</span></span><br><span class="line">point1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">point2 = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算明科夫斯基距离</span></span><br><span class="line">minkowski_distance = np.linalg.norm(point1 - point2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 3D 图形对象</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制点1和点2</span></span><br><span class="line">ax.scatter(point1[<span class="number">0</span>], point1[<span class="number">1</span>], point1[<span class="number">2</span>], color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;Point 1&#x27;</span>)</span><br><span class="line">ax.scatter(point2[<span class="number">0</span>], point2[<span class="number">1</span>], point2[<span class="number">2</span>], color=<span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;Point 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制连接两点的线段</span></span><br><span class="line">ax.plot([point1[<span class="number">0</span>], point2[<span class="number">0</span>]], [point1[<span class="number">1</span>], point2[<span class="number">1</span>]], [point1[<span class="number">2</span>], point2[<span class="number">2</span>]], color=<span class="string">&#x27;g&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, label=<span class="string">&#x27;Distance&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图形属性</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;X-axis&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Y-axis&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;Z-axis&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;Minkowski Distance&#x27;</span>)</span><br><span class="line">ax.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;明科夫斯基距离:&quot;</span>, minkowski_distance)</span><br></pre></td></tr></table></figure>

<p>得到的结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323161400871.png" alt="image-20240323161400871"></p>
<p><u><strong>Cosine distance</strong></u></p>
<p>余弦距离（Cosine distance）是用于衡量向量之间相似性的一种距离度量方式。它度量的是两个向量之间的夹角的余弦值的反比，即两个向量的方向上的差异性。余弦距离越小，表示两个向量在方向上越相似；余弦距离越大，表示两个向量在方向上越不相似。</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323221737288.png" alt="image-20240323221737288"></p>
<p>其中，$\mathbf{A}$ 和 $\mathbf{B}$ 分别是两个向量，$A_i$ 和 $B_i$ 分别是这两个向量中的第 $i$ 个元素，$\theta$ 是两个向量之间的夹角，而 $ n$ 是向量的维度。</p>
<p>其中，$ A \cdot B $ 表示向量 $ A $ 和向量 $ B $ 的点积（内积），而 $ |A| $ 和 $ |B| $ 分别表示向量 $ A $ 和向量 $ B $ 的模（范数）。</p>
<p>余弦距离的取值范围为 [0, 2]，当两个向量的夹角为 0° 时，余弦距离为 0，表示两个向量完全相似；当两个向量的夹角为 180° 时，余弦距离为 2，表示两个向量完全不相似。</p>
<p>余弦距离常用于文本分类、信息检索等领域，尤其是当向量表示文档或文本数据时，可以用余弦距离来度量文档之间的相似性。</p>
<p>Python语言代码为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_distances</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个向量</span></span><br><span class="line">vector1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">vector2 = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算余弦距离</span></span><br><span class="line">cos_distance = cosine_distances([vector1], [vector2])[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印计算结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;余弦距离:&quot;</span>, cos_distance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化向量</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot([<span class="number">0</span>, vector1[<span class="number">0</span>]], [<span class="number">0</span>, vector1[<span class="number">1</span>]], <span class="string">&#x27;ro--&#x27;</span>, label=<span class="string">&#x27;Vector 1&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, vector2[<span class="number">0</span>]], [<span class="number">0</span>, vector2[<span class="number">1</span>]], <span class="string">&#x27;bo--&#x27;</span>, label=<span class="string">&#x27;Vector 2&#x27;</span>)</span><br><span class="line">plt.xlim(-<span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">plt.ylim(-<span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X-axis&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y-axis&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Cosine Distance&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show() <span class="comment"># 得到的结果：余弦距离: 0.025368153802923787</span></span><br></pre></td></tr></table></figure>

<p>可视化：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323161710130.png" alt="image-20240323161710130"></p>
<p><u><strong>Jaccard距离</strong></u></p>
<p>Jaccard 距离（Jaccard distance）是用于度量两个集合之间相异度的一种距离度量方式。它是通过集合中元素的交集与并集的比值来衡量两个集合的相异程度。</p>
<p>抱歉，我犯了一个错误。实际上，Jaccard 距离并不是 1 减去 Jaccard 相似度，而是表示两个集合之间的不相交部分与它们的并集的比率。</p>
<p>Jaccard 距离的正确公式如下：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323221839425.png" alt="image-20240323221839425"></p>
<p>这里，$|A \cap B|$ 表示集合 $A$ 和集合 $B$ 的交集的元素个数，$|A \cup B|$ 表示集合 $A$ 和集合 $B$ 的并集的元素个数。</p>
<p>使用Python语言代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> jaccard_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个集合</span></span><br><span class="line">set1 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">set2 = <span class="built_in">set</span>([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 Jaccard 距离</span></span><br><span class="line">intersection_size = <span class="built_in">len</span>(set1.intersection(set2))</span><br><span class="line">union_size = <span class="built_in">len</span>(set1.union(set2))</span><br><span class="line">jaccard_distance = <span class="number">1</span> - (intersection_size / union_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印计算结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Jaccard 距离:&quot;</span>, jaccard_distance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化集合</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制集合1的 Venn 图</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Set 1&#x27;</span>)</span><br><span class="line">venn_diagram1 = plt.Circle((<span class="number">0.3</span>, <span class="number">0.5</span>), <span class="number">0.2</span>, color=<span class="string">&#x27;r&#x27;</span>, alpha=<span class="number">0.5</span>, label=<span class="string">&#x27;Set 1&#x27;</span>)</span><br><span class="line">plt.gca().add_patch(venn_diagram1)</span><br><span class="line">plt.text(<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(set1)), fontsize=<span class="number">12</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制集合2的 Venn 图</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Set 2&#x27;</span>)</span><br><span class="line">venn_diagram2 = plt.Circle((<span class="number">0.7</span>, <span class="number">0.5</span>), <span class="number">0.2</span>, color=<span class="string">&#x27;b&#x27;</span>, alpha=<span class="number">0.5</span>, label=<span class="string">&#x27;Set 2&#x27;</span>)</span><br><span class="line">plt.gca().add_patch(venn_diagram2)</span><br><span class="line">plt.text(<span class="number">0.7</span>, <span class="number">0.5</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(set2)), fontsize=<span class="number">12</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>得到的结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323164359155.png" alt="image-20240323164359155"></p>
<h2 id="聚类类型与聚类算法"><a href="#聚类类型与聚类算法" class="headerlink" title="聚类类型与聚类算法"></a>聚类类型与聚类算法</h2><p><u><strong>几种算法</strong></u></p>
<p>这里是常见的几种聚类算法：</p>
<ol>
<li><p>**Hierarchical clustering (AGNES, DIANA)**：层次聚类是一种基于对象之间相似性度量的聚类方法。AGNES（自下而上的聚合式聚类）首先将每个数据点视为一个独立的簇，然后迭代地合并相似的簇，直到所有数据点都合并到一个簇中。DIANA（自上而下的分解式聚类）则是从一个大的簇开始，逐步分裂，直到每个簇包含一个数据点。这两种方法都以树形结构（聚类树或者树状图）表示聚类结果。</p>
</li>
<li><p>**Partition-based clustering (k-Means, k-Medoids)**：分割式聚类是一种基于距离的聚类方法，它将数据划分为 k 个簇，每个簇包含最接近的数据点。k-Means 算法是其中最常见的方法，它通过迭代优化簇的中心来最小化每个数据点与其所属簇中心的距离的平方和。k-Medoids 算法是 k-Means 的一种变体，它使用数据点本身作为簇的中心，更适用于离散数据或者离群点较多的情况。</p>
</li>
<li><p><strong>Mean-shift clustering</strong>：均值漂移聚类是一种基于密度的非参数聚类方法，它不需要预先指定簇的数量。该算法通过在数据空间中移动窗口来寻找数据点密度的局部极大值，并将窗口中的数据点移向密度更高的区域。最终，数据点收敛到局部密度的峰值处，形成簇。</p>
</li>
<li><p>**Density-Based Spatial Clustering of Applications with Noise (DBSCAN)**：DBSCAN 是一种基于密度的聚类算法，它将密度高于某个阈值的区域定义为簇，并能够识别噪声点。该算法根据数据点的密度来发现任意形状的簇，对于密度不均匀的数据和噪声点较多的情况表现较好。</p>
</li>
<li><p><strong>Expectation–Maximization (EM) Clustering</strong>：EM 聚类是一种基于概率模型的聚类方法，通常用于高斯混合模型（Gaussian Mixture Model，GMM）。该算法假设数据是由多个高斯分布混合而成的，并通过迭代地最大化似然函数来估计模型参数，从而找到数据的最佳聚类。EM 聚类适用于数据分布不均匀且簇之间有重叠的情况。</p>
</li>
</ol>
<p><u><strong>层次聚类算法</strong></u></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.hierarchy <span class="keyword">import</span> dendrogram, linkage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成样本数据</span></span><br><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">              [<span class="number">8</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">8</span>], [<span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">              [<span class="number">25</span>, <span class="number">80</span>], [<span class="number">30</span>, <span class="number">90</span>], [<span class="number">27</span>, <span class="number">88</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用AGNES进行层次聚类</span></span><br><span class="line">linked = linkage(X, <span class="string">&#x27;single&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化聚类结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">dendrogram(linked,</span><br><span class="line">           orientation=<span class="string">&#x27;top&#x27;</span>,</span><br><span class="line">           labels=<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>),</span><br><span class="line">           distance_sort=<span class="string">&#x27;descending&#x27;</span>,</span><br><span class="line">           show_leaf_counts=<span class="literal">True</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Hierarchical Clustering Dendrogram&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sample Index&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Distance&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>可视化的结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323165341659.png" alt="image-20240323165341659"></p>
<p>在这段代码中，我们首先生成了一组示例数据 <code>X</code>，然后使用 <code>linkage</code> 函数基于单链接（single linkage）方法进行层次聚类。接下来，使用 <code>dendrogram</code> 函数可视化了聚类结果，绘制了聚类树的树状图（树状图中每个叶节点代表一个数据点，树的分支表示数据点之间的相似性）。</p>
<p><u><strong>K-Means算法</strong></u></p>
<p>Python语言代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">k_means</span>(<span class="params">X, k, max_iters=<span class="number">100</span></span>):</span><br><span class="line">    <span class="comment"># 随机初始化聚类中心</span></span><br><span class="line">    centroids = X[np.random.choice(<span class="built_in">range</span>(<span class="built_in">len</span>(X)), k, replace=<span class="literal">False</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iters):</span><br><span class="line">        <span class="comment"># 计算每个样本到聚类中心的距离</span></span><br><span class="line">        distances = np.sqrt(((X - centroids[:, np.newaxis])**<span class="number">2</span>).<span class="built_in">sum</span>(axis=<span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 分配样本到最近的聚类中心</span></span><br><span class="line">        labels = np.argmin(distances, axis=<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新聚类中心</span></span><br><span class="line">        new_centroids = np.array([X[labels == i].mean(axis=<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果聚类中心不再改变，则停止迭代</span></span><br><span class="line">        <span class="keyword">if</span> np.<span class="built_in">all</span>(centroids == new_centroids):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        centroids = new_centroids</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> centroids, labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">X = np.random.rand(<span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置聚类数目</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行k-means算法</span></span><br><span class="line">centroids, labels = k_means(X, k)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化聚类结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=labels, cmap=<span class="string">&#x27;viridis&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.scatter(centroids[:, <span class="number">0</span>], centroids[:, <span class="number">1</span>], marker=<span class="string">&#x27;x&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>, s=<span class="number">100</span>, label=<span class="string">&#x27;Centroids&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;K-Means Clustering&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Feature 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Feature 2&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>可视化的结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323165524283.png" alt="image-20240323165524283"></p>
<p>在这段代码中，我们首先定义了一个 <code>k_means</code> 函数，它实现了 k-means 算法。然后，我们生成了一组示例数据 <code>X</code>，并设置了聚类数目 <code>k</code>。接着，我们运行了 k-means 算法并得到了聚类中心 <code>centroids</code> 和每个样本的标签 <code>labels</code>。最后，我们使用 Matplotlib 对聚类结果进行了可视化。</p>
<p>另外一种可视化结果：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323165557120.png" alt="image-20240323165557120"></p>
<p><strong><u>Mean-shift clustering</u></strong> </p>
<p>Mean-shift 聚类是一种基于密度的非参数聚类方法，它不需要事先指定聚类的数量，能够自动发现数据中的簇。该算法通过在数据空间中移动窗口（即 kernel）来寻找数据点密度的局部极大值，并将窗口中的数据点移向密度更高的区域。最终，数据点会收敛到局部密度的峰值处，形成簇。</p>
<p>具体而言，Mean-shift 聚类的过程如下：</p>
<ol>
<li>初始化每个数据点为一个窗口的中心。</li>
<li>对于每个窗口，计算窗口内所有数据点的质心（即均值）。</li>
<li>将窗口中心移动到其对应质心的位置。</li>
<li>重复步骤 2 和步骤 3，直到窗口中心不再改变或者达到收敛条件。</li>
<li>将所有收敛的窗口中心归类到最近的聚类中心，形成最终的簇。</li>
</ol>
<p>Mean-shift 聚类适用于发现任意形状的簇，对于密度不均匀的数据和噪声点较多的情况表现较好。它的一个重要参数是窗口的大小（bandwidth），该参数影响了密度估计的精度和最终聚类结果的形状。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MeanShift</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">X, _ = make_blobs(n_samples=<span class="number">300</span>, centers=<span class="number">4</span>, cluster_std=<span class="number">0.6</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 Mean-shift 聚类算法</span></span><br><span class="line">ms = MeanShift()</span><br><span class="line">ms.fit(X)</span><br><span class="line">labels = ms.labels_</span><br><span class="line">cluster_centers = ms.cluster_centers_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制聚类结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=labels, cmap=<span class="string">&#x27;viridis&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">plt.scatter(cluster_centers[:, <span class="number">0</span>], cluster_centers[:, <span class="number">1</span>], marker=<span class="string">&#x27;x&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>, s=<span class="number">100</span>, label=<span class="string">&#x27;Cluster Centers&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Mean-Shift Clustering&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Feature 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Feature 2&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>得到的结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323170014385.png" alt="image-20240323170014385"></p>
<p><strong><u>DBSCAN</u></strong></p>
<p>DBSCAN（Density-Based Spatial Clustering of Applications with Noise）是一种基于密度的空间聚类算法，它能够有效地发现具有变化密度的任意形状的簇，并且可以识别噪声点。DBSCAN 根据数据点周围的密度来进行聚类，而不是依赖于预先指定的簇的数量。</p>
<p>DBSCAN 算法的主要思想是通过两个参数：ε（eps）和 MinPts，来对数据点进行分类：</p>
<ol>
<li>ε（eps）参数用于定义邻域的大小。具体而言，对于每个数据点，算法会找到距离该点 ε 内的所有邻居点。</li>
<li>MinPts 参数用于定义一个簇的最小样本数。如果某个数据点的 ε-邻域内包含至少 MinPts 个数据点（包括该点自身），则该点被认为是核心点（core point）。</li>
</ol>
<p>DBSCAN 算法的主要步骤如下：</p>
<ol>
<li>随机选择一个未被访问的数据点作为起始点。</li>
<li>根据 ε 和 MinPts 参数，找到该点的 ε-邻域内的所有数据点。</li>
<li>如果该点是核心点，则将其所在的簇确定为一个新的簇，并递归地将其所有密度可达的邻居点加入到该簇中。</li>
<li>如果该点是边界点（边界点在 ε-邻域内的数据点少于 MinPts 个），则将其标记为边界点，并将其归入某个核心点所在的簇。</li>
<li>如果该点是噪声点（即其 ε-邻域内的数据点少于 MinPts 个），则将其标记为噪声点。</li>
</ol>
<p>通过这种方式，DBSCAN 能够自动发现具有不同密度和任意形状的簇，并且能够有效地处理噪声数据。</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323170137424.png" alt="image-20240323170137424"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn.manifold <span class="keyword">import</span> TSNE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">X, _ = make_blobs(n_samples=<span class="number">300</span>, centers=<span class="number">3</span>, cluster_std=<span class="number">0.6</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 DBSCAN 聚类算法</span></span><br><span class="line">dbscan = DBSCAN(eps=<span class="number">0.5</span>, min_samples=<span class="number">5</span>)</span><br><span class="line">labels = dbscan.fit_predict(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 t-SNE 进行降维</span></span><br><span class="line">tsne = TSNE(n_components=<span class="number">2</span>)</span><br><span class="line">X_tsne = tsne.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化聚类结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">plt.scatter(X_tsne[:, <span class="number">0</span>], X_tsne[:, <span class="number">1</span>], c=labels, cmap=<span class="string">&#x27;viridis&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;DBSCAN Clustering (t-SNE Visualization)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;t-SNE Feature 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;t-SNE Feature 2&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323170259910.png" alt="image-20240323170259910"></p>
<p><u><strong>EM Cluster</strong></u></p>
<p>EM（Expectation-Maximization）聚类是一种基于概率模型的聚类算法，通常用于高斯混合模型（Gaussian Mixture Model，GMM）。它假设数据是由多个高斯分布混合而成的，并通过迭代地最大化似然函数来估计模型参数，从而找到数据的最佳聚类。</p>
<p>EM 聚类的主要思想是通过迭代的方式估计数据点的分布情况和每个分布的参数。它的算法过程包括两个主要步骤：期望步骤（Expectation Step，E步）和最大化步骤（Maximization Step，M步）。</p>
<ol>
<li><p><strong>期望步骤（E步）</strong>：在 E 步中，根据当前的模型参数估计值，计算每个数据点属于每个分布的后验概率（即每个分布生成每个数据点的概率），并将这些后验概率作为权重。</p>
</li>
<li><p><strong>最大化步骤（M步）</strong>：在 M 步中，根据 E 步中计算得到的权重，更新模型参数，以最大化似然函数。</p>
</li>
</ol>
<p>通过交替执行这两个步骤，直到模型参数收敛为止，就能够得到最优的模型参数估计值，从而实现数据的聚类。</p>
<p>EM 聚类适用于数据分布不均匀且簇之间有重叠的情况。它的一个重要优点是能够给出每个数据点属于每个簇的后验概率，而不是仅仅给出硬聚类结果，这使得它更加灵活。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">X, _ = make_blobs(n_samples=<span class="number">300</span>, centers=<span class="number">4</span>, cluster_std=<span class="number">0.6</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 EM 聚类算法</span></span><br><span class="line">gmm = GaussianMixture(n_components=<span class="number">4</span>)</span><br><span class="line">gmm.fit(X)</span><br><span class="line">labels = gmm.predict(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化聚类结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=labels, cmap=<span class="string">&#x27;viridis&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;EM Clustering&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Feature 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Feature 2&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323170443695.png" alt="image-20240323170443695"></p>
<p>  一个动态的过程：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323170556064.png" alt="image-20240323170556064"></p>
<p>不同的方案会导致不同的结果：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323170627297.png" alt="image-20240323170627297"></p>
<h1 id="数据集和R语言代码"><a href="#数据集和R语言代码" class="headerlink" title="数据集和R语言代码"></a>数据集和R语言代码</h1><p>Tourist Risk Taking数据集。</p>
<p>这个数据集包含563名受访者对自己在六个类别下的风险行为频率进行评估。这六个类别是：</p>
<ol>
<li>休闲风险：例如攀岩、潜水等；</li>
<li>健康风险：例如吸烟、不良饮食、高酒精摄入等；</li>
<li>职业风险：例如辞职而没有下一个工作的冒险；</li>
<li>金融风险：例如赌博、风险投资等；</li>
<li>安全风险：例如超速行驶等；</li>
<li>社会风险：例如参选、公开挑战某项规则或决定等。</li>
</ol>
<p>受访者根据一个五级有序量表对这些风险行为的频率进行评估，包括以下选项：</p>
<ol>
<li>从不（NEVER）</li>
<li>很少（RARELY）</li>
<li>相当经常（QUITE OFTEN）</li>
<li>经常（OFTEN）</li>
<li>非常经常（VERY OFTEN）</li>
</ol>
<p>该数据集的目的可能是研究人们在不同类型的风险行为上的态度和行为倾向，以及这些倾向与个人特征之间的关系。可能的分析方向包括探索不同风险类别之间的相关性、了解特定人群对特定风险类别的偏好程度、分析与其他个人特征（如年龄、性别、教育水平等）之间的关系等。通过对这些数据的分析，可以揭示人们在面临各种风险时的心理和行为模式，为风险管理和干预措施提供参考。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> risk <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span><span class="string">&quot;risk.csv&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">dim</span><span class="punctuation">(</span>risk<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">563</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>读取了名为 “risk.csv” 的数据集，并显示其维度为 563 行和 6 列。这意味着该数据集包含了 563 个受访者的风险行为数据，每个受访者针对六个风险类别提供了评估。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> head<span class="punctuation">(</span>risk<span class="punctuation">)</span></span><br><span class="line">  Recreational Health Career Financial Safety Social</span><br><span class="line"><span class="number">1</span>            <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span>         <span class="number">2</span>      <span class="number">2</span>      <span class="number">4</span></span><br><span class="line"><span class="number">2</span>            <span class="number">1</span>      <span class="number">1</span>      <span class="number">1</span>         <span class="number">1</span>      <span class="number">1</span>      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>            <span class="number">2</span>      <span class="number">2</span>      <span class="number">1</span>         <span class="number">1</span>      <span class="number">2</span>      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>            <span class="number">1</span>      <span class="number">1</span>      <span class="number">1</span>         <span class="number">1</span>      <span class="number">1</span>      <span class="number">1</span></span><br><span class="line"><span class="number">5</span>            <span class="number">5</span>      <span class="number">4</span>      <span class="number">1</span>         <span class="number">3</span>      <span class="number">5</span>      <span class="number">5</span></span><br><span class="line"><span class="number">6</span>            <span class="number">5</span>      <span class="number">2</span>      <span class="number">5</span>         <span class="number">3</span>      <span class="number">2</span>      <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>接着是：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> colMeans<span class="punctuation">(</span>risk<span class="punctuation">)</span></span><br><span class="line">Recreational       Health       Career    Financial       Safety </span><br><span class="line">    <span class="number">2.190053</span>     <span class="number">2.396092</span>     <span class="number">2.007105</span>     <span class="number">2.026643</span>     <span class="number">2.266430</span> </span><br><span class="line">      Social </span><br><span class="line">    <span class="number">2.017762</span> </span><br></pre></td></tr></table></figure>

<p>计算了数据集中每个变量（风险类别）的平均值。下面是每个风险类别的平均评分：</p>
<ul>
<li>休闲风险（Recreational）: 平均评分约为 2.19</li>
<li>健康风险（Health）: 平均评分约为 2.40</li>
<li>职业风险（Career）: 平均评分约为 2.01</li>
<li>金融风险（Financial）: 平均评分约为 2.03</li>
<li>安全风险（Safety）: 平均评分约为 2.27</li>
<li>社会风险（Social）: 平均评分约为 2.02</li>
</ul>
<p>这些平均评分可以了解整体上受访者对不同类型风险的感知程度。</p>
<p>使用曼哈顿距离：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> risk.dist <span class="operator">&lt;-</span> dist<span class="punctuation">(</span>risk<span class="punctuation">,</span> method <span class="operator">=</span> <span class="string">&quot;manhattan&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> risk.hc1 <span class="operator">&lt;-</span> hclust<span class="punctuation">(</span>risk.dist<span class="punctuation">,</span> method <span class="operator">=</span> <span class="string">&quot;complete&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> risk.hc1</span><br><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">hclust<span class="punctuation">(</span>d <span class="operator">=</span> risk.dist<span class="punctuation">,</span> method <span class="operator">=</span> <span class="string">&quot;complete&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Cluster method   <span class="operator">:</span> complete </span><br><span class="line">Distance         <span class="operator">:</span> manhattan </span><br><span class="line">Number of objects<span class="operator">:</span> <span class="number">563</span> </span><br></pre></td></tr></table></figure>

<p>这段代码是用 R 语言进行层次聚类分析的操作。让我来解释一下每一行的含义：</p>
<ol>
<li><p><code>risk.dist &lt;- dist(risk, method = &quot;manhattan&quot;)</code>：</p>
<ul>
<li><code>dist()</code> 函数用于计算数据集中观测值之间的距离。</li>
<li><code>risk</code> 是数据集，包含了受访者对六种风险的评分。</li>
<li><code>method = &quot;manhattan&quot;</code> 表示使用曼哈顿距离来度量观测值之间的距离。</li>
<li><code>risk.dist</code> 是一个距离矩阵，其中每个元素表示相应观测值之间的曼哈顿距离。</li>
</ul>
</li>
<li><p><code>risk.hc1 &lt;- hclust(risk.dist, method = &quot;complete&quot;)</code>：</p>
<ul>
<li><code>hclust()</code> 函数用于进行层次聚类分析。</li>
<li><code>risk.dist</code> 是距离矩阵，用于指定观测值之间的距离。</li>
<li><code>method = &quot;complete&quot;</code> 表示使用 complete linkage 方法进行聚类，即采用最大距离法来确定簇之间的距离。</li>
<li><code>risk.hc1</code> 是一个层次聚类对象，它包含了聚类结果和树状图的信息。</li>
</ul>
</li>
<li><p><code>risk.hc1</code> 打印输出：</p>
<ul>
<li>打印了聚类方法、距离度量方法和观测值数量等信息。</li>
</ul>
</li>
</ol>
<p>通过这些代码，可以得到基于曼哈顿距离和 complete linkage 方法的层次聚类结果，可以进一步分析簇之间的关系和受访者的聚类情况。</p>
<p>代码为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>risk.hc1<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> labels <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323184837154.png" alt="image-20240323184837154"></p>
<p>接着是cutree：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> c20 <span class="operator">&lt;-</span> cutree<span class="punctuation">(</span>risk.hc1<span class="punctuation">,</span> h <span class="operator">=</span> <span class="number">20</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> table<span class="punctuation">(</span>c20<span class="punctuation">)</span></span><br><span class="line">c20</span><br><span class="line">  <span class="number">1</span>   <span class="number">2</span> </span><br><span class="line"><span class="number">511</span>  <span class="number">52</span> </span><br><span class="line"><span class="operator">&gt;</span> c6 <span class="operator">&lt;-</span> cutree<span class="punctuation">(</span>risk.hc1<span class="punctuation">,</span> k <span class="operator">=</span> <span class="number">6</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> table<span class="punctuation">(</span>c6<span class="punctuation">)</span></span><br><span class="line">c6</span><br><span class="line">  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span> </span><br><span class="line"> <span class="number">90</span> <span class="number">275</span>  <span class="number">27</span>  <span class="number">25</span>  <span class="number">74</span>  <span class="number">72</span> </span><br></pre></td></tr></table></figure>

<p>这段代码涉及到使用 <code>cutree()</code> 函数从层次聚类结果中切割出指定数量的簇，并统计每个簇中的观测值数量。下面是代码的解释和结果的解释：</p>
<ol>
<li><p><code>c20 &lt;- cutree(risk.hc1, h = 20)</code>：</p>
<ul>
<li><code>cutree()</code> 函数用于从层次聚类结果中切割出指定高度（<code>h</code>）的簇。</li>
<li><code>risk.hc1</code> 是之前进行层次聚类分析得到的层次聚类对象。</li>
<li><code>h = 20</code> 表示将树剪枝至高度为 20，以得到具有 20 个簇的聚类结果。这个操作是指在层次聚类的树状图上剪切树枝，使得树的高度不超过 20。这样做的目的是得到一个具有较大数量簇的聚类结果，可以用于更细粒度地分析数据中的群集结构。</li>
<li><code>c20</code> 是一个向量，包含了每个观测值所属的簇标签。</li>
<li><code>table(c20)</code> 用于统计每个簇中观测值的数量。</li>
</ul>
</li>
<li><p><code>table(c20)</code> 的结果解释：</p>
<ul>
<li>从结果中可见，剪枝至高度 20 后，共得到了 2 个簇。</li>
<li>第一个簇中有 511 个观测值，第二个簇中有 52 个观测值。</li>
</ul>
</li>
<li><p><code>c6 &lt;- cutree(risk.hc1, k = 6)</code>：</p>
<ul>
<li>同样使用 <code>cutree()</code> 函数，但这次指定要得到 6 个簇。</li>
<li><code>k = 6</code> 表示要切割出 6 个簇。这种做法通常用于在一开始就明确地确定所需的聚类数量，以便后续分析和解释。</li>
<li><code>c6</code> 是一个向量，包含了每个观测值所属的簇标签。</li>
<li><code>table(c6)</code> 用于统计每个簇中观测值的数量。</li>
</ul>
</li>
<li><p><code>table(c6)</code> 的结果解释：</p>
<ul>
<li>切割出 6 个簇后，每个簇中观测值的数量如下：<ul>
<li>第一个簇中有 90 个观测值</li>
<li>第二个簇中有 275 个观测值</li>
<li>第三个簇中有 27 个观测值</li>
<li>第四个簇中有 25 个观测值</li>
<li>第五个簇中有 74 个观测值</li>
<li>第六个簇中有 72 个观测值</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>这些代码和结果给出了根据层次聚类结果切割出不同数量簇的情况，以及每个簇中观测值的数量。</p>
<p>接着是mean：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> c20.means <span class="operator">&lt;-</span> aggregate<span class="punctuation">(</span>risk<span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span>Cluster <span class="operator">=</span> c20<span class="punctuation">)</span><span class="punctuation">,</span> mean<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">round</span><span class="punctuation">(</span>c20.means<span class="punctuation">[</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">  Recreational Health Career Financial Safety Social</span><br><span class="line"><span class="number">1</span>            <span class="number">2</span>    <span class="number">2.2</span>    <span class="number">1.9</span>       <span class="number">1.9</span>    <span class="number">2.2</span>    <span class="number">1.9</span></span><br><span class="line"><span class="number">2</span>            <span class="number">4</span>    <span class="number">3.9</span>    <span class="number">3.4</span>       <span class="number">3.0</span>    <span class="number">3.3</span>    <span class="number">3.6</span></span><br></pre></td></tr></table></figure>

<p>这段代码涉及到对每个簇中观测值的平均评分进行聚合，并且对结果进行了舍入处理。以下是代码和结果的解释：</p>
<ol>
<li><p><code>c20.means &lt;- aggregate(risk, list(Cluster = c20), mean)</code>：</p>
<ul>
<li><code>aggregate()</code> 函数用于对数据进行聚合操作。</li>
<li><code>risk</code> 是您的数据集，包含了受访者对六种风险的评分。</li>
<li><code>list(Cluster = c20)</code> 将聚合的依据设置为之前切割出的 20 个簇的标签。</li>
<li><code>mean</code> 表示对每个簇中观测值进行平均计算。</li>
<li><code>c20.means</code> 是一个数据框，包含了每个簇中各风险类别的平均评分。</li>
</ul>
</li>
<li><p><code>round(c20.means[, -1], 1)</code>：</p>
<ul>
<li><code>round()</code> 函数用于对数据进行舍入处理。</li>
<li><code>c20.means[, -1]</code> 选择了除第一列（即簇标签列）之外的所有列。</li>
<li><code>1</code> 是舍入到小数点后一位。</li>
</ul>
</li>
<li><p>结果解释：</p>
<ul>
<li>结果中有两行，分别对应于切割出的两个簇。</li>
<li>每一列代表了对应风险类别的平均评分。</li>
<li>第一行表示第一个簇的平均评分，第二行表示第二个簇的平均评分。</li>
<li>每个数字表示对应风险类别的平均评分，经过了小数点后一位的舍入处理。</li>
</ul>
</li>
</ol>
<p>c6的mean：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> c6 <span class="operator">&lt;-</span> cutree<span class="punctuation">(</span>risk.hc1<span class="punctuation">,</span> k <span class="operator">=</span> <span class="number">6</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> c6.means <span class="operator">&lt;-</span> aggregate<span class="punctuation">(</span>risk<span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span>Cluster <span class="operator">=</span> c6<span class="punctuation">)</span><span class="punctuation">,</span> mean<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">round</span><span class="punctuation">(</span>c6.means<span class="punctuation">[</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">  Recreational Health Career Financial Safety Social</span><br><span class="line"><span class="number">1</span>          <span class="number">2.0</span>    <span class="number">2.2</span>    <span class="number">1.9</span>       <span class="number">2.0</span>    <span class="number">2.2</span>    <span class="number">2.8</span></span><br><span class="line"><span class="number">2</span>          <span class="number">1.9</span>    <span class="number">1.8</span>    <span class="number">1.5</span>       <span class="number">1.6</span>    <span class="number">2.0</span>    <span class="number">1.4</span></span><br><span class="line"><span class="number">3</span>          <span class="number">3.9</span>    <span class="number">4.4</span>    <span class="number">2.9</span>       <span class="number">3.2</span>    <span class="number">3.3</span>    <span class="number">4.1</span></span><br><span class="line"><span class="number">4</span>          <span class="number">4.1</span>    <span class="number">3.3</span>    <span class="number">4.1</span>       <span class="number">2.8</span>    <span class="number">3.4</span>    <span class="number">3.2</span></span><br><span class="line"><span class="number">5</span>          <span class="number">2.3</span>    <span class="number">2.6</span>    <span class="number">3.2</span>       <span class="number">2.6</span>    <span class="number">2.6</span>    <span class="number">2.2</span></span><br><span class="line"><span class="number">6</span>          <span class="number">2.0</span>    <span class="number">3.8</span>    <span class="number">1.8</span>       <span class="number">2.4</span>    <span class="number">2.3</span>    <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p>这段代码涉及到切割出 6 个簇后，对每个簇中观测值的平均评分进行聚合，并对结果进行舍入处理。以下是代码和结果的解释：</p>
<ol>
<li><p><code>c6 &lt;- cutree(risk.hc1, k = 6)</code>：</p>
<ul>
<li>使用 <code>cutree()</code> 函数切割出 6 个簇。</li>
<li><code>risk.hc1</code> 是之前进行层次聚类分析得到的层次聚类对象。</li>
<li><code>k = 6</code> 表示要切割出 6 个簇。</li>
<li><code>c6</code> 是一个向量，包含了每个观测值所属的簇标签。</li>
</ul>
</li>
<li><p><code>c6.means &lt;- aggregate(risk, list(Cluster = c6), mean)</code>：</p>
<ul>
<li>使用 <code>aggregate()</code> 函数对数据进行聚合操作。</li>
<li><code>risk</code> 是您的数据集，包含了受访者对六种风险的评分。</li>
<li><code>list(Cluster = c6)</code> 将聚合的依据设置为切割出的 6 个簇的标签。</li>
<li><code>mean</code> 表示对每个簇中观测值进行平均计算。</li>
<li><code>c6.means</code> 是一个数据框，包含了每个簇中各风险类别的平均评分。</li>
</ul>
</li>
<li><p><code>round(c6.means[, -1], 1)</code>：</p>
<ul>
<li>使用 <code>round()</code> 函数对数据进行舍入处理。</li>
<li><code>c6.means[, -1]</code> 选择了除第一列（即簇标签列）之外的所有列。</li>
<li><code>1</code> 是舍入到小数点后一位。</li>
</ul>
</li>
<li><p>结果解释：</p>
<ul>
<li>结果中有 6 行，每行对应一个簇。</li>
<li>每一列代表了对应风险类别的平均评分。</li>
<li>每个数字表示对应风险类别的平均评分，经过了小数点后一位的舍入处理。</li>
</ul>
</li>
</ol>
<p>绘图：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;flexclust&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">barchart<span class="punctuation">(</span>risk.hc1<span class="punctuation">,</span> risk<span class="punctuation">,</span> k <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>可视化结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323190803521.png" alt="image-20240323190803521"></p>
<p>同样的：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">barchart<span class="punctuation">(</span>risk.hc1<span class="punctuation">,</span> risk<span class="punctuation">,</span> k <span class="operator">=</span> <span class="number">6</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>可视化的结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323190919377.png" alt="image-20240323190919377"></p>
<p>接着是fviz_cluster的可视化结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span>dbscan<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span>readr<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span><span class="string">&quot;factoextra&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> risk <span class="operator">&lt;-</span> read_csv<span class="punctuation">(</span><span class="string">&quot;risk.csv&quot;</span><span class="punctuation">)</span></span><br><span class="line">Rows<span class="operator">:</span> <span class="number">563</span> Columns<span class="operator">:</span> <span class="number">6</span>                                                                                                                                                              </span><br><span class="line">── Column specification ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">Delimiter<span class="operator">:</span> <span class="string">&quot;,&quot;</span></span><br><span class="line">dbl <span class="punctuation">(</span><span class="number">6</span><span class="punctuation">)</span><span class="operator">:</span> Recreational<span class="punctuation">,</span> Health<span class="punctuation">,</span> Career<span class="punctuation">,</span> Financial<span class="punctuation">,</span> Safety<span class="punctuation">,</span> Social</span><br><span class="line"></span><br><span class="line">ℹ Use `spec()` to retrieve the full column specification <span class="keyword">for</span> this data.</span><br><span class="line">ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</span><br><span class="line"><span class="operator">&gt;</span> res.db <span class="operator">&lt;-</span> dbscan<span class="punctuation">(</span>risk<span class="punctuation">,</span> eps<span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span> minPts <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> res.db</span><br><span class="line">DBSCAN clustering <span class="keyword">for</span> <span class="number">563</span> objects.</span><br><span class="line">Parameters<span class="operator">:</span> eps <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span> minPts <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">Using euclidean distances and borderpoints <span class="operator">=</span> <span class="literal">TRUE</span></span><br><span class="line">The clustering contains <span class="number">2</span> cluster<span class="punctuation">(</span>s<span class="punctuation">)</span> and <span class="number">66</span> noise points.</span><br><span class="line"></span><br><span class="line">  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span> </span><br><span class="line"> <span class="number">66</span> <span class="number">487</span>  <span class="number">10</span> </span><br><span class="line"></span><br><span class="line">Available fields<span class="operator">:</span> cluster<span class="punctuation">,</span> eps<span class="punctuation">,</span> minPts<span class="punctuation">,</span> dist<span class="punctuation">,</span> borderPoints</span><br><span class="line"><span class="operator">&gt;</span> fviz_cluster<span class="punctuation">(</span>res.db<span class="punctuation">,</span> risk<span class="punctuation">,</span> geom <span class="operator">=</span> <span class="string">&quot;point&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>得到的结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323191243906.png" alt="image-20240323191243906"></p>
<p>这段代码使用了 <code>dbscan</code> 包中的 <code>dbscan()</code> 函数进行密度聚类分析，然后使用了 <code>factoextra</code> 包中的 <code>fviz_cluster()</code> 函数对聚类结果进行可视化。下面是代码和结果的解释：</p>
<ol>
<li><p><code>res.db &lt;- dbscan(risk, eps= 1.5, minPts = 5)</code>：</p>
<ul>
<li><code>dbscan()</code> 函数用于执行密度聚类分析。</li>
<li><code>risk</code> 是您的数据集，包含了受访者对六种风险的评分。</li>
<li><code>eps= 1.5</code> 指定了邻域半径（epsilon）的大小为 1.5，用于定义密度可达的邻域。</li>
<li><code>minPts = 5</code> 指定了邻域中最少需要包含的点的数量，用于定义核心点。</li>
<li><code>res.db</code> 是一个聚类结果对象，包含了聚类的相关信息，如簇标签、噪声点等。</li>
</ul>
</li>
<li><p><code>res.db</code> 结果解释：</p>
<ul>
<li>输出展示了 DBSCAN 聚类的结果。</li>
<li>聚类参数为 epsilon（eps）&#x3D; 1.5 和 minPts &#x3D; 5。</li>
<li>结果包含了 2 个聚类簇和 66 个噪声点。</li>
<li>具体的聚类情况如下：<ul>
<li>0: 噪声点，有 66 个</li>
<li>1: 聚类簇 1，有 487 个点</li>
<li>2: 聚类簇 2，有 10 个点</li>
</ul>
</li>
</ul>
</li>
<li><p><code>fviz_cluster(res.db, risk, geom = &quot;point&quot;)</code>：</p>
<ul>
<li><code>fviz_cluster()</code> 函数用于对聚类结果进行可视化。</li>
<li><code>res.db</code> 是聚类结果对象。</li>
<li><code>risk</code> 是原始数据集。</li>
<li><code>geom = &quot;point&quot;</code> 指定了可视化中使用点来表示观测值。</li>
</ul>
</li>
<li><p>可视化结果：</p>
<ul>
<li>可视化结果显示了数据集中的观测值以及它们所属的聚类簇。不同颜色的点代表不同的聚类簇，而灰色点代表噪声点。</li>
</ul>
</li>
</ol>
<p>接着的代码为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span>EMCluster<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> emobj <span class="operator">&lt;-</span> simple.init<span class="punctuation">(</span>risk<span class="punctuation">,</span> nclass <span class="operator">=</span> <span class="number">6</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> risk.em <span class="operator">&lt;-</span> emcluster<span class="punctuation">(</span>risk<span class="punctuation">,</span> emobj<span class="punctuation">,</span> assign.class <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> par<span class="punctuation">(</span>mfrow <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> plotem<span class="punctuation">(</span>risk.em<span class="punctuation">,</span> risk<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>risk.em<span class="punctuation">)</span></span><br><span class="line">Method<span class="operator">:</span> </span><br><span class="line"> n <span class="operator">=</span> <span class="number">563</span><span class="punctuation">,</span> p <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> nclass <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> flag <span class="operator">=</span> <span class="punctuation">,</span> total parameters <span class="operator">=</span> <span class="number">167</span><span class="punctuation">,</span></span><br><span class="line"> conv.iter <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> conv.eps <span class="operator">=</span> <span class="number">3.974202</span><span class="punctuation">,</span></span><br><span class="line"> logL <span class="operator">=</span> <span class="number">11711.3577</span><span class="punctuation">,</span> AIC <span class="operator">=</span> <span class="operator">-</span><span class="number">23088.7154</span><span class="punctuation">,</span> BIC <span class="operator">=</span> <span class="operator">-</span><span class="number">22365.0577</span>.</span><br><span class="line">nc<span class="operator">:</span> </span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span>  <span class="number">91</span> <span class="number">204</span>  <span class="number">98</span>  <span class="number">21</span> <span class="number">107</span>  <span class="number">42</span></span><br><span class="line"><span class="built_in">pi</span><span class="operator">:</span> </span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">0.24188</span> <span class="number">0.18969</span> <span class="number">0.18449</span> <span class="number">0.03669</span> <span class="number">0.23268</span> <span class="number">0.11458</span></span><br></pre></td></tr></table></figure>

<p>这段代码和输出的解释如下：</p>
<ol>
<li><p><code>library(EMCluster)</code>: 加载了 <code>EMCluster</code> 包，该包提供了执行期望最大化聚类的函数。</p>
</li>
<li><p><code>emobj &lt;- simple.init(risk, nclass = 6)</code>: 使用 <code>simple.init()</code> 函数对数据进行初始参数的估计。</p>
<ul>
<li><code>risk</code> 是您的数据集，包含了受访者对六种风险的评分。</li>
<li><code>nclass = 6</code> 指定了要划分的簇的数量。</li>
</ul>
</li>
<li><p><code>risk.em &lt;- emcluster(risk, emobj, assign.class = TRUE)</code>: 使用 <code>emcluster()</code> 函数执行期望最大化聚类。</p>
<ul>
<li><code>risk</code> 是原始数据集。</li>
<li><code>emobj</code> 是通过 <code>simple.init()</code> 函数估计的初始参数。</li>
<li><code>assign.class = TRUE</code> 表示将观测值分配到聚类簇中。</li>
</ul>
</li>
<li><p><code>par(mfrow = c(1, 1))</code>: 设置绘图参数，将图形排列为一行一列。</p>
</li>
<li><p><code>plotem(risk.em, risk)</code>: 使用 <code>plotem()</code> 函数可视化期望最大化聚类的结果。</p>
<ul>
<li><code>risk.em</code> 是期望最大化聚类的结果对象。</li>
<li><code>risk</code> 是原始数据集。</li>
</ul>
</li>
<li><p><code>summary(risk.em)</code>: 打印出期望最大化聚类的摘要信息，包括模型的相关参数和统计信息。</p>
<ul>
<li><code>Method</code>: 显示了期望最大化聚类的参数设置，如样本大小、变量数量、簇数量、收敛迭代次数、对数似然值（logL）等。</li>
<li><code>nc</code>: 显示了每个聚类簇中的观测值数量。</li>
<li><code>pi</code>: 显示了每个聚类簇的先验概率。</li>
</ul>
</li>
</ol>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323194633721.png" alt="image-20240323194633721"></p>
<p>这个可视化是一个显示在6个维度上的563个数据点的图像。每个三角形代表一个数据点在特定两个维度上的投影。随着维度增加,图像看起来越来越复杂和密集。</p>
<p>这种可视化方式被称为平行坐标图(Parallel Coordinates Plot)。它通过绘制每个数据点在所有维度上的值,并将这些值连接成一条折线,从而在二维平面上显示多维数据。</p>
<p>这种可视化技术有助于探索高维数据集中的模式和关系。通过观察折线的聚类、分组和趋势,可以发现数据中的簇和离群点。同时,也有助于识别哪些维度之间存在相关性。</p>
<p>然而,对于大型数据集和高维度,平行坐标图可能会变得非常拥挤和难以解读。在这种情况下,可以考虑使用其他可视化技术,如散点图矩阵(Scatter Plot Matrix)或降维技术(如主成分分析PCA)等,来更好地探索和呈现数据。</p>
<p>总的来说,这个可视化展示了高维数据集的复杂性,并为进一步的数据分析和可视化提供了一种有用的起点。</p>
<p>代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span>cluster<span class="punctuation">)</span> </span><br><span class="line"><span class="operator">&gt;</span> clusplot<span class="punctuation">(</span>risk<span class="punctuation">,</span> risk.em<span class="operator">$</span><span class="built_in">class</span><span class="punctuation">,</span> color<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">,</span> shade<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">,</span> labels<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> lines<span class="operator">=</span><span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> em.means <span class="operator">&lt;-</span> aggregate<span class="punctuation">(</span>risk<span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span>Cluster <span class="operator">=</span> risk.em<span class="operator">$</span><span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">,</span> mean<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">round</span><span class="punctuation">(</span>em.means<span class="punctuation">[</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">  Recreational Health Career Financial Safety Social</span><br><span class="line"><span class="number">1</span>          <span class="number">1.9</span>    <span class="number">2.0</span>    <span class="number">2.1</span>       <span class="number">2.0</span>    <span class="number">2.0</span>    <span class="number">1.8</span></span><br><span class="line"><span class="number">2</span>          <span class="number">1.8</span>    <span class="number">2.0</span>    <span class="number">1.0</span>       <span class="number">1.7</span>    <span class="number">2.0</span>    <span class="number">1.6</span></span><br><span class="line"><span class="number">3</span>          <span class="number">2.6</span>    <span class="number">3.1</span>    <span class="number">3.2</span>       <span class="number">2.5</span>    <span class="number">3.0</span>    <span class="number">2.5</span></span><br><span class="line"><span class="number">4</span>          <span class="number">4.4</span>    <span class="number">4.0</span>    <span class="number">3.8</span>       <span class="number">3.5</span>    <span class="number">4.0</span>    <span class="number">4.1</span></span><br><span class="line"><span class="number">5</span>          <span class="number">2.3</span>    <span class="number">2.7</span>    <span class="number">2.3</span>       <span class="number">2.3</span>    <span class="number">2.0</span>    <span class="number">2.4</span></span><br><span class="line"><span class="number">6</span>          <span class="number">2.5</span>    <span class="number">1.6</span>    <span class="number">2.2</span>       <span class="number">1.4</span>    <span class="number">2.4</span>    <span class="number">1.3</span></span><br></pre></td></tr></table></figure>

<p>这段代码和输出的解释如下：</p>
<ol>
<li><p><code>library(cluster)</code>: 加载了 <code>cluster</code> 包，该包提供了进行聚类分析的函数。</p>
</li>
<li><p><code>clusplot(risk, risk.em$class, color=TRUE, shade=TRUE, labels=2, lines=0)</code>: 使用 <code>clusplot()</code> 函数绘制了聚类簇的可视化图形。</p>
<ul>
<li><code>risk</code> 是原始数据集。</li>
<li><code>risk.em$class</code> 是期望最大化聚类结果对象中的聚类标签。</li>
<li><code>color=TRUE</code> 表示在图中使用颜色来区分不同的聚类簇。</li>
<li><code>shade=TRUE</code> 表示在图中使用阴影来突出显示不同的聚类簇。</li>
<li><code>labels=2</code> 表示标签的位置：2 表示使用变量名的缩写，1 表示使用变量名的全称，0 表示不显示标签。</li>
<li><code>lines=0</code> 表示不绘制连线。</li>
</ul>
</li>
<li><p>可视化结果解释：</p>
<ul>
<li>图中的每个点代表数据集中的一个观测值，而不同颜色的点表示不同的聚类簇。</li>
<li>如果聚类簇之间有明显的空间分离或重叠，可以根据图形来判断聚类结果的合理性和有效性。</li>
</ul>
</li>
<li><p><code>em.means &lt;- aggregate(risk, list(Cluster = risk.em$class), mean)</code>: 使用 <code>aggregate()</code> 函数计算了每个聚类簇中各个变量的平均值。</p>
<ul>
<li><code>risk</code> 是原始数据集。</li>
<li><code>risk.em$class</code> 是期望最大化聚类结果对象中的聚类标签。</li>
<li><code>mean</code> 表示计算平均值。</li>
</ul>
</li>
<li><p><code>round(em.means[, -1], 1)</code>: 对计算的平均值进行了舍入处理，保留了一位小数，并排除了第一列（即聚类簇标签）。</p>
<ul>
<li>结果显示了每个聚类簇中各个风险类别的平均评分。</li>
</ul>
</li>
</ol>
<p>可视化的结果为：</p>
<p><img src="/2024/03/23/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-03%EF%BC%9A%E5%B8%82%E5%9C%BA%E7%BB%86%E5%88%86/image-20240323195343526.png" alt="image-20240323195343526"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>市场细分 - 是否进行？</strong></p>
<p>市场细分是将大型市场划分为更小的子群体或细分市场的过程。这个过程涉及到对消费者进行分类，以便更好地理解其需求、偏好和行为。但是否应该进行市场细分取决于许多因素，包括市场的大小、竞争情况、产品的特性以及公司的资源。有时候，市场细分可以帮助公司更精准地定位其目标受众并开展有效的营销活动，但在其他情况下，它可能会增加成本并导致资源浪费。</p>
<p><strong>市场细分方法：基于业务规则与基于聚类</strong></p>
<p>市场细分方法通常可以分为基于业务规则和基于聚类两种类型。基于业务规则的方法是依据公司的先验知识、经验或行业常规来划分市场，例如基于地理位置、年龄、收入等因素。而基于聚类的方法则是利用数据驱动的技术，通过分析消费者数据来发现潜在的群体并划分市场。</p>
<p><strong>需要考虑的变量</strong></p>
<p>在进行市场细分时，需要考虑的变量通常包括消费者的特征、行为、偏好以及其他相关因素。这些变量可以是地理信息、年龄、性别、收入、购买历史、兴趣爱好等。选择合适的变量对于正确划分市场至关重要。</p>
<p><strong>距离度量</strong></p>
<p>在基于聚类的市场细分方法中，距离度量是一个重要的概念。它用于衡量不同观察值之间的相似性或差异性。常用的距离度量包括欧氏距离、曼哈顿距离、余弦相似度等。</p>
<p><strong>One-hot编码</strong></p>
<p>在聚类分析中，如果涉及到分类变量，通常需要将其转换为数值形式，其中一种常用的方法就是One-hot编码。这种编码方法将分类变量转换为二进制的数值表示，便于在算法中进行处理和分析。</p>
<p><strong>聚类算法</strong></p>
<p>市场细分的核心是聚类算法，常用的包括层次聚类、k均值聚类、DBSCAN等。每种算法都有其适用的场景和特点，选择合适的算法取决于数据的性质以及分析的目的。</p>
<p><strong>聚类结果的解释</strong></p>
<p>最后，对聚类结果的解释是市场细分过程中至关重要的一步。通过对聚类簇的特征和特点进行解释，可以帮助企业更好地理解不同消费者群体的需求和行为，从而制定更有针对性的营销策略和产品定位。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" rel="tag"># 数据分析</a>
              <a href="/tags/%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90/" rel="tag"># 客户分析</a>
              <a href="/tags/%E7%BB%9F%E8%AE%A1/" rel="tag"># 统计</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/03/17/%E4%BA%BA%E7%94%9F12%E6%9D%A1%E6%B3%95%E5%88%99/" rel="prev" title="人生12条法则">
                  <i class="fa fa-chevron-left"></i> 人生12条法则
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/03/26/%E5%A4%A7%E5%9E%8B%E7%BB%84%E7%BB%87%E4%B8%AD%E7%9A%84%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90-04%EF%BC%9A%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/" rel="next" title="大型组织中的客户分析-04：概率分布">
                  大型组织中的客户分析-04：概率分布 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ye Jiu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
